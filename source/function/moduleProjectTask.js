"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.entryointCLI = exports.entrypointProgrammaticAPI = exports.transpileTarget = exports.transpilePackageDependency = exports.copyYarnLockfile = exports.removeDistributionFolder = exports.module_installYarn = void 0;var _path = _interopRequireDefault(require("path"));
var _fs = require("fs");

var _util = _interopRequireDefault(require("util"));
var _stream = _interopRequireDefault(require("stream"));


var _rimraf = _interopRequireDefault(require("rimraf"));



var _glob = _interopRequireDefault(require("glob"));


var _installYarn = require("@dependency/deploymentScript/script/provisionOS/installESModule/install-yarn.js");

var _synchronizeFile = require("@dependency/deploymentScript/source/utility/filesystemOperation/synchronizeFile.js");






var _javascriptTranspilation = require("@dependency/javascriptTranspilation");const pipeline = _util.default.promisify(_stream.default.pipeline);const rimraf = _util.default.promisify(_rimraf.default);const wildcardPathnameMatcher = _util.default.promisify(_glob.default);
const packageDependencyPatternMatch = '**/@package*/**/*',
nodeModulePatternMatch = '**/node_modules/**/*';

const module_installYarn = ({ node, context }) => {
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));
  (0, _installYarn.installYarn)({ yarnPath: _path.default.join(targetProjectConfig.directory.source) });
};exports.module_installYarn = module_installYarn;

const removeDistributionFolder = async ({ node, context }) => {
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));


  let fileStat = await _fs.promises.lstat(targetProjectConfig.directory.distribution).catch(error => error.code == 'ENOENT' ? false : console.error(error));
  if (fileStat && fileStat.isDirectory()) await rimraf(targetProjectConfig.directory.distribution, { disableGlob: false });

  await _fs.promises.mkdir(targetProjectConfig.directory.distribution, { recursive: true });
};exports.removeDistributionFolder = removeDistributionFolder;

const copyYarnLockfile = async ({ node, context }) => {
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));
  let filePath = _path.default.join(targetProjectConfig.directory.root, 'yarn.lock');
  let fileStat = await _fs.promises.lstat(filePath).catch(error => error.code == 'ENOENT' ? false : console.error(error));
  if (fileStat && fileStat.isFile()) await (0, _synchronizeFile.copyFileAndSymlink)({ source: filePath, destination: targetProjectConfig.directory.distribution });
};exports.copyYarnLockfile = copyYarnLockfile;

const transpilePackageDependency = async ({ node, context }) => {
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));
  let sourceRelativePath = './package.json';
  await (0, _javascriptTranspilation.transpileSourcePath)({ source: sourceRelativePath, destination: targetProjectConfig.directory.distribution, basePath: targetProjectConfig.directory.root });


};exports.transpilePackageDependency = transpilePackageDependency;

const transpileTarget = async ({ node, context }) => {var _node$properties;
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));
  let sourceRelativePath = ((_node$properties = node.properties) === null || _node$properties === void 0 ? void 0 : _node$properties.relativePath) || function (e) {throw e;}(new Error(`• relativePath must exist on stage node that uses this condition for evaluation.`));
  return await (0, _javascriptTranspilation.transpileSourcePath)({ source: sourceRelativePath, destination: targetProjectConfig.directory.distribution, basePath: targetProjectConfig.directory.root });
};exports.transpileTarget = transpileTarget;

const entrypointProgrammaticAPI = async ({ node, context }) => {
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));

  let enrtypointKey = 'programmaticAPI';
  if (!(targetProjectConfig === null || targetProjectConfig === void 0 ? void 0 : targetProjectConfig.entrypoint) || !(targetProjectConfig === null || targetProjectConfig === void 0 ? void 0 : targetProjectConfig.entrypoint[enrtypointKey])) return;

  let scriptTargetFile = _path.default.join(targetProjectConfig.directory.source, targetProjectConfig.entrypoint[enrtypointKey]);
  let entrypointFolder = _path.default.join(targetProjectConfig.directory.root, `./entrypoint/${enrtypointKey}`);


  let relativeTargetFile = _path.default.relative(entrypointFolder, scriptTargetFile);

  let destinationFolder = _path.default.join(targetProjectConfig.directory.distribution, _path.default.relative(targetProjectConfig.directory.root, entrypointFolder));
  await _fs.promises.mkdir(destinationFolder, { recursive: true });


  let filePath = _path.default.join(destinationFolder, 'index.js');
  let content = `module.exports = require('${relativeTargetFile}')`;
  await _fs.promises.appendFile(filePath, content, { encoding: 'utf8' });
};exports.entrypointProgrammaticAPI = entrypointProgrammaticAPI;

const entryointCLI = async ({ node, context }) => {
  let targetProjectConfig = context.targetProjectConfig || function (e) {throw e;}(new Error(`• Context "targetProjectConfig" variable is required to run project dependent tasks.`));

  let enrtypointKey = 'cli';
  if (!(targetProjectConfig === null || targetProjectConfig === void 0 ? void 0 : targetProjectConfig.entrypoint) || !(targetProjectConfig === null || targetProjectConfig === void 0 ? void 0 : targetProjectConfig.entrypoint[enrtypointKey])) return;

  let scriptTargetFile = _path.default.join(targetProjectConfig.directory.source, targetProjectConfig.entrypoint[enrtypointKey]);
  let entrypointFolder = _path.default.join(targetProjectConfig.directory.root, `./entrypoint/${enrtypointKey}`);


  let relativeTargetFile = _path.default.relative(entrypointFolder, scriptTargetFile);

  let destinationFolder = _path.default.join(targetProjectConfig.directory.distribution, _path.default.relative(targetProjectConfig.directory.root, entrypointFolder));
  await _fs.promises.mkdir(destinationFolder, { recursive: true });


  let filePath = _path.default.join(destinationFolder, 'index.js');
  let content = `module.exports = require('${relativeTargetFile}')`;
  content = `#\!/usr/bin/env node\n` + content;
  await _fs.promises.appendFile(filePath, content, { encoding: 'utf8' });
};exports.entryointCLI = entryointCLI;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS9mdW5jdGlvbi9tb2R1bGVQcm9qZWN0VGFzay5qcyJdLCJuYW1lcyI6WyJwaXBlbGluZSIsInV0aWwiLCJwcm9taXNpZnkiLCJzdHJlYW0iLCJyaW1yYWYiLCJyaW1yYWZDYWxsYmFjayIsIndpbGRjYXJkUGF0aG5hbWVNYXRjaGVyIiwib3JpZ2luYWxfd2lsZGNhcmRQYXRobmFtZU1hdGNoZXIiLCJwYWNrYWdlRGVwZW5kZW5jeVBhdHRlcm5NYXRjaCIsIm5vZGVNb2R1bGVQYXR0ZXJuTWF0Y2giLCJtb2R1bGVfaW5zdGFsbFlhcm4iLCJub2RlIiwiY29udGV4dCIsInRhcmdldFByb2plY3RDb25maWciLCJFcnJvciIsInlhcm5QYXRoIiwicGF0aCIsImpvaW4iLCJkaXJlY3RvcnkiLCJzb3VyY2UiLCJyZW1vdmVEaXN0cmlidXRpb25Gb2xkZXIiLCJmaWxlU3RhdCIsImZpbGVzeXN0ZW0iLCJsc3RhdCIsImRpc3RyaWJ1dGlvbiIsImNhdGNoIiwiZXJyb3IiLCJjb2RlIiwiY29uc29sZSIsImlzRGlyZWN0b3J5IiwiZGlzYWJsZUdsb2IiLCJta2RpciIsInJlY3Vyc2l2ZSIsImNvcHlZYXJuTG9ja2ZpbGUiLCJmaWxlUGF0aCIsInJvb3QiLCJpc0ZpbGUiLCJkZXN0aW5hdGlvbiIsInRyYW5zcGlsZVBhY2thZ2VEZXBlbmRlbmN5Iiwic291cmNlUmVsYXRpdmVQYXRoIiwiYmFzZVBhdGgiLCJ0cmFuc3BpbGVUYXJnZXQiLCJwcm9wZXJ0aWVzIiwicmVsYXRpdmVQYXRoIiwiZW50cnlwb2ludFByb2dyYW1tYXRpY0FQSSIsImVucnR5cG9pbnRLZXkiLCJlbnRyeXBvaW50Iiwic2NyaXB0VGFyZ2V0RmlsZSIsImVudHJ5cG9pbnRGb2xkZXIiLCJyZWxhdGl2ZVRhcmdldEZpbGUiLCJyZWxhdGl2ZSIsImRlc3RpbmF0aW9uRm9sZGVyIiwiY29udGVudCIsImFwcGVuZEZpbGUiLCJlbmNvZGluZyIsImVudHJ5b2ludENMSSJdLCJt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SUFBOUQ7QUFDQUcsRUFBQUEsT0FBTyxHQUFJLHdCQUFELEdBQTJCQSxPQUFyQztBQUNBLFFBQU05QixhQUFXK0IsVUFBWCxDQUFzQm5CLFFBQXRCLEVBQWdDa0IsT0FBaEMsRUFBeUMsRUFBRUUsUUFBUSxFQUFFLE1BQVosRUFBekMsQ0FBTjtBQUNELENBcEJNLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZmlsZXN5c3RlbSB9IGZyb20gJ2ZzJ1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnXG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJ1xuaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nXG5jb25zdCBwaXBlbGluZSA9IHV0aWwucHJvbWlzaWZ5KHN0cmVhbS5waXBlbGluZSlcbmltcG9ydCBtZXJnZVN0cmVhbSBmcm9tICdtZXJnZS1zdHJlYW0nXG5pbXBvcnQgcmltcmFmQ2FsbGJhY2sgZnJvbSAncmltcmFmJ1xuY29uc3QgcmltcmFmID0gdXRpbC5wcm9taXNpZnkocmltcmFmQ2FsbGJhY2spXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ3VscGpzL3ZpbnlsLWZzI2Rlc3Rmb2xkZXItb3B0aW9ucyAmIGh0dHBzOi8vZ3VscGpzLmNvbS9kb2NzL2VuL2FwaS9zcmNcbmltcG9ydCB7IHNyYyBhcyByZWFkRmlsZUFzT2JqZWN0U3RyZWFtLCBkZXN0IGFzIHdyaXRlRmlsZUZyb21PYmplY3RTdHJlYW0gfSBmcm9tICd2aW55bC1mcydcbmltcG9ydCBvcmlnaW5hbF93aWxkY2FyZFBhdGhuYW1lTWF0Y2hlciBmcm9tICdnbG9iJyAvLyBBbHRlcm5hdGl2ZSBtb2R1bGVzIC0gYGdsb2JieWAsIGBnbG9iYCwgYGdsb2Itc3RyZWFtYFxuY29uc3Qgd2lsZGNhcmRQYXRobmFtZU1hdGNoZXIgPSB1dGlsLnByb21pc2lmeShvcmlnaW5hbF93aWxkY2FyZFBhdGhuYW1lTWF0Y2hlcilcbmltcG9ydCB7IGluc3RhbGxKc3BtIH0gZnJvbSAnQGRlcGVuZGVuY3kvZGVwbG95bWVudFNjcmlwdC9zY3JpcHQvcHJvdmlzaW9uT1MvaW5zdGFsbEVTTW9kdWxlL2luc3RhbGwtanNwbS5qcydcbmltcG9ydCB7IGluc3RhbGxZYXJuIH0gZnJvbSAnQGRlcGVuZGVuY3kvZGVwbG95bWVudFNjcmlwdC9zY3JpcHQvcHJvdmlzaW9uT1MvaW5zdGFsbEVTTW9kdWxlL2luc3RhbGwteWFybi5qcydcbmltcG9ydCB7IGluc3RhbGxOcG0gfSBmcm9tICdAZGVwZW5kZW5jeS9kZXBsb3ltZW50U2NyaXB0L3NjcmlwdC9wcm92aXNpb25PUy9pbnN0YWxsRVNNb2R1bGUvaW5zdGFsbC1ucG0uanMnXG5pbXBvcnQgeyByZWN1cnNpdmVseVN5bmNGaWxlLCBjb3B5RmlsZUFuZFN5bWxpbmsgfSBmcm9tICdAZGVwZW5kZW5jeS9kZXBsb3ltZW50U2NyaXB0L3NvdXJjZS91dGlsaXR5L2ZpbGVzeXN0ZW1PcGVyYXRpb24vc3luY2hyb25pemVGaWxlLmpzJ1xuaW1wb3J0IHsgcGlwZWxpbmUgYXMgaHRtbFBpcGVsaW5lIH0gZnJvbSAnLi4vdHJhbnNmb3JtUGlwZWxpbmUvaHRtbC5qcydcbmltcG9ydCB7IHBpcGVsaW5lIGFzIGltYWdlUGlwZWxpbmUgfSBmcm9tICcuLi90cmFuc2Zvcm1QaXBlbGluZS9pbWFnZS5qcydcbmltcG9ydCB7IGNsaWVudEpTUGlwZWxpbmUsIHNlcnZlckpTUGlwZWxpbmUgfSBmcm9tICcuLi90cmFuc2Zvcm1QaXBlbGluZS9qYXZhc2NyaXB0LmpzJ1xuaW1wb3J0IHsgcGlwZWxpbmUgYXMganNvblBpcGVsaW5lIH0gZnJvbSAnLi4vdHJhbnNmb3JtUGlwZWxpbmUvanNvbi5qcydcbmltcG9ydCB7IHBpcGVsaW5lIGFzIHN0eWxlc2hlZXRQaXBlbGluZSB9IGZyb20gJy4uL3RyYW5zZm9ybVBpcGVsaW5lL3N0eWxlc2hlZXQuanMnXG5pbXBvcnQgeyBjb252ZXJ0QXJyYXlUb011bHRpcGxlUGF0dGVybkdsb2IgfSBmcm9tICcuLi91dGlsaXR5L2NvbnZlcnRBcnJheVRvTXVsdGlwbGVQYXR0ZXJuR2xvYi5qcydcbmltcG9ydCB7IHRyYW5zcGlsZVNvdXJjZVBhdGggfSBmcm9tICdAZGVwZW5kZW5jeS9qYXZhc2NyaXB0VHJhbnNwaWxhdGlvbidcbmNvbnN0IHBhY2thZ2VEZXBlbmRlbmN5UGF0dGVybk1hdGNoID0gJyoqL0BwYWNrYWdlKi8qKi8qJywgLy8gYEBwYWNrYWdlLy4uLmAgYEBwYWNrYWdlLXgvLi4uYFxuICBub2RlTW9kdWxlUGF0dGVybk1hdGNoID0gJyoqL25vZGVfbW9kdWxlcy8qKi8qJ1xuXG5leHBvcnQgY29uc3QgbW9kdWxlX2luc3RhbGxZYXJuID0gKHsgbm9kZSwgY29udGV4dCB9KSA9PiB7XG4gIGxldCB0YXJnZXRQcm9qZWN0Q29uZmlnID0gY29udGV4dC50YXJnZXRQcm9qZWN0Q29uZmlnIHx8IHRocm93IG5ldyBFcnJvcihg4oCiIENvbnRleHQgXCJ0YXJnZXRQcm9qZWN0Q29uZmlnXCIgdmFyaWFibGUgaXMgcmVxdWlyZWQgdG8gcnVuIHByb2plY3QgZGVwZW5kZW50IHRhc2tzLmApXG4gIGluc3RhbGxZYXJuKHsgeWFyblBhdGg6IHBhdGguam9pbih0YXJnZXRQcm9qZWN0Q29uZmlnLmRpcmVjdG9yeS5zb3VyY2UpIH0pXG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVEaXN0cmlidXRpb25Gb2xkZXIgPSBhc3luYyAoeyBub2RlLCBjb250ZXh0IH0pID0+IHtcbiAgbGV0IHRhcmdldFByb2plY3RDb25maWcgPSBjb250ZXh0LnRhcmdldFByb2plY3RDb25maWcgfHwgdGhyb3cgbmV3IEVycm9yKGDigKIgQ29udGV4dCBcInRhcmdldFByb2plY3RDb25maWdcIiB2YXJpYWJsZSBpcyByZXF1aXJlZCB0byBydW4gcHJvamVjdCBkZXBlbmRlbnQgdGFza3MuYClcbiAgLy8gaHR0cHM6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L2Z1bmN0aW9ucy9ybWRpci5odG1sXG4gIC8vIGh0dHBzOi8vd3d3LnVuaXguY29tL21hbi1wYWdlL3Bvc2l4LzNwb3NpeC9ybWRpci9cbiAgbGV0IGZpbGVTdGF0ID0gYXdhaXQgZmlsZXN5c3RlbS5sc3RhdCh0YXJnZXRQcm9qZWN0Q29uZmlnLmRpcmVjdG9yeS5kaXN0cmlidXRpb24pLmNhdGNoKGVycm9yID0+IChlcnJvci5jb2RlID09ICdFTk9FTlQnID8gZmFsc2UgOiBjb25zb2xlLmVycm9yKGVycm9yKSkpXG4gIGlmIChmaWxlU3RhdCAmJiBmaWxlU3RhdC5pc0RpcmVjdG9yeSgpKSBhd2FpdCByaW1yYWYodGFyZ2V0UHJvamVjdENvbmZpZy5kaXJlY3RvcnkuZGlzdHJpYnV0aW9uLCB7IGRpc2FibGVHbG9iOiBmYWxzZSB9KVxuICAvLyBjcmVhdGUgYW4gZW1wdHkgZGlzdHJpYnV0aW9uIGZvbGRlclxuICBhd2FpdCBmaWxlc3lzdGVtLm1rZGlyKHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LmRpc3RyaWJ1dGlvbiwgeyByZWN1cnNpdmU6IHRydWUgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGNvcHlZYXJuTG9ja2ZpbGUgPSBhc3luYyAoeyBub2RlLCBjb250ZXh0IH0pID0+IHtcbiAgbGV0IHRhcmdldFByb2plY3RDb25maWcgPSBjb250ZXh0LnRhcmdldFByb2plY3RDb25maWcgfHwgdGhyb3cgbmV3IEVycm9yKGDigKIgQ29udGV4dCBcInRhcmdldFByb2plY3RDb25maWdcIiB2YXJpYWJsZSBpcyByZXF1aXJlZCB0byBydW4gcHJvamVjdCBkZXBlbmRlbnQgdGFza3MuYClcbiAgbGV0IGZpbGVQYXRoID0gcGF0aC5qb2luKHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LnJvb3QsICd5YXJuLmxvY2snKVxuICBsZXQgZmlsZVN0YXQgPSBhd2FpdCBmaWxlc3lzdGVtLmxzdGF0KGZpbGVQYXRoKS5jYXRjaChlcnJvciA9PiAoZXJyb3IuY29kZSA9PSAnRU5PRU5UJyA/IGZhbHNlIDogY29uc29sZS5lcnJvcihlcnJvcikpKVxuICBpZiAoZmlsZVN0YXQgJiYgZmlsZVN0YXQuaXNGaWxlKCkpIGF3YWl0IGNvcHlGaWxlQW5kU3ltbGluayh7IHNvdXJjZTogZmlsZVBhdGgsIGRlc3RpbmF0aW9uOiB0YXJnZXRQcm9qZWN0Q29uZmlnLmRpcmVjdG9yeS5kaXN0cmlidXRpb24gfSlcbn1cblxuZXhwb3J0IGNvbnN0IHRyYW5zcGlsZVBhY2thZ2VEZXBlbmRlbmN5ID0gYXN5bmMgKHsgbm9kZSwgY29udGV4dCB9KSA9PiB7XG4gIGxldCB0YXJnZXRQcm9qZWN0Q29uZmlnID0gY29udGV4dC50YXJnZXRQcm9qZWN0Q29uZmlnIHx8IHRocm93IG5ldyBFcnJvcihg4oCiIENvbnRleHQgXCJ0YXJnZXRQcm9qZWN0Q29uZmlnXCIgdmFyaWFibGUgaXMgcmVxdWlyZWQgdG8gcnVuIHByb2plY3QgZGVwZW5kZW50IHRhc2tzLmApXG4gIGxldCBzb3VyY2VSZWxhdGl2ZVBhdGggPSAnLi9wYWNrYWdlLmpzb24nXG4gIGF3YWl0IHRyYW5zcGlsZVNvdXJjZVBhdGgoeyBzb3VyY2U6IHNvdXJjZVJlbGF0aXZlUGF0aCwgZGVzdGluYXRpb246IHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LmRpc3RyaWJ1dGlvbiwgYmFzZVBhdGg6IHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LnJvb3QgfSlcbiAgLy8gcmVtb3ZlIGRldiBkZXBlbmRlbmljZXNcbiAgLy8gVE9ETzogLSByZW1vdmUgZGV2IGRlcGVuZGVuY2llcyBmcm9tIHBhY2thZ2UuanNvbi5cbn1cblxuZXhwb3J0IGNvbnN0IHRyYW5zcGlsZVRhcmdldCA9IGFzeW5jICh7IG5vZGUsIGNvbnRleHQgfSkgPT4ge1xuICBsZXQgdGFyZ2V0UHJvamVjdENvbmZpZyA9IGNvbnRleHQudGFyZ2V0UHJvamVjdENvbmZpZyB8fCB0aHJvdyBuZXcgRXJyb3IoYOKAoiBDb250ZXh0IFwidGFyZ2V0UHJvamVjdENvbmZpZ1wiIHZhcmlhYmxlIGlzIHJlcXVpcmVkIHRvIHJ1biBwcm9qZWN0IGRlcGVuZGVudCB0YXNrcy5gKVxuICBsZXQgc291cmNlUmVsYXRpdmVQYXRoID0gbm9kZS5wcm9wZXJ0aWVzPy5yZWxhdGl2ZVBhdGggfHwgdGhyb3cgbmV3IEVycm9yKGDigKIgcmVsYXRpdmVQYXRoIG11c3QgZXhpc3Qgb24gc3RhZ2Ugbm9kZSB0aGF0IHVzZXMgdGhpcyBjb25kaXRpb24gZm9yIGV2YWx1YXRpb24uYClcbiAgcmV0dXJuIGF3YWl0IHRyYW5zcGlsZVNvdXJjZVBhdGgoeyBzb3VyY2U6IHNvdXJjZVJlbGF0aXZlUGF0aCwgZGVzdGluYXRpb246IHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LmRpc3RyaWJ1dGlvbiwgYmFzZVBhdGg6IHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LnJvb3QgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGVudHJ5cG9pbnRQcm9ncmFtbWF0aWNBUEkgPSBhc3luYyAoeyBub2RlLCBjb250ZXh0IH0pID0+IHtcbiAgbGV0IHRhcmdldFByb2plY3RDb25maWcgPSBjb250ZXh0LnRhcmdldFByb2plY3RDb25maWcgfHwgdGhyb3cgbmV3IEVycm9yKGDigKIgQ29udGV4dCBcInRhcmdldFByb2plY3RDb25maWdcIiB2YXJpYWJsZSBpcyByZXF1aXJlZCB0byBydW4gcHJvamVjdCBkZXBlbmRlbnQgdGFza3MuYClcblxuICBsZXQgZW5ydHlwb2ludEtleSA9ICdwcm9ncmFtbWF0aWNBUEknXG4gIGlmICghdGFyZ2V0UHJvamVjdENvbmZpZz8uZW50cnlwb2ludCB8fCAhdGFyZ2V0UHJvamVjdENvbmZpZz8uZW50cnlwb2ludFtlbnJ0eXBvaW50S2V5XSkgcmV0dXJuXG5cbiAgbGV0IHNjcmlwdFRhcmdldEZpbGUgPSBwYXRoLmpvaW4odGFyZ2V0UHJvamVjdENvbmZpZy5kaXJlY3Rvcnkuc291cmNlLCB0YXJnZXRQcm9qZWN0Q29uZmlnLmVudHJ5cG9pbnRbZW5ydHlwb2ludEtleV0pXG4gIGxldCBlbnRyeXBvaW50Rm9sZGVyID0gcGF0aC5qb2luKHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LnJvb3QsIGAuL2VudHJ5cG9pbnQvJHtlbnJ0eXBvaW50S2V5fWApXG5cbiAgLy8gcGF0aCB0byB0aGUgdGFyZ2V0IHNjcmlwdCBmaWxlIGZyb20gdGhlIGVudHJ5cG9pbnQgZmlsZS5cbiAgbGV0IHJlbGF0aXZlVGFyZ2V0RmlsZSA9IHBhdGgucmVsYXRpdmUoZW50cnlwb2ludEZvbGRlciwgc2NyaXB0VGFyZ2V0RmlsZSlcblxuICBsZXQgZGVzdGluYXRpb25Gb2xkZXIgPSBwYXRoLmpvaW4odGFyZ2V0UHJvamVjdENvbmZpZy5kaXJlY3RvcnkuZGlzdHJpYnV0aW9uLCBwYXRoLnJlbGF0aXZlKHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LnJvb3QsIGVudHJ5cG9pbnRGb2xkZXIpKVxuICBhd2FpdCBmaWxlc3lzdGVtLm1rZGlyKGRlc3RpbmF0aW9uRm9sZGVyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KSAvLyBjcmVhdGUgZm9sZGVyIHJlY3Vyc2l2ZWx5XG5cbiAgLy8gY3JlYXRlIGVudHJ5cG9pbnRcbiAgbGV0IGZpbGVQYXRoID0gcGF0aC5qb2luKGRlc3RpbmF0aW9uRm9sZGVyLCAnaW5kZXguanMnKVxuICBsZXQgY29udGVudCA9IGBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJyR7cmVsYXRpdmVUYXJnZXRGaWxlfScpYFxuICBhd2FpdCBmaWxlc3lzdGVtLmFwcGVuZEZpbGUoZmlsZVBhdGgsIGNvbnRlbnQsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KVxufVxuXG5leHBvcnQgY29uc3QgZW50cnlvaW50Q0xJID0gYXN5bmMgKHsgbm9kZSwgY29udGV4dCB9KSA9PiB7XG4gIGxldCB0YXJnZXRQcm9qZWN0Q29uZmlnID0gY29udGV4dC50YXJnZXRQcm9qZWN0Q29uZmlnIHx8IHRocm93IG5ldyBFcnJvcihg4oCiIENvbnRleHQgXCJ0YXJnZXRQcm9qZWN0Q29uZmlnXCIgdmFyaWFibGUgaXMgcmVxdWlyZWQgdG8gcnVuIHByb2plY3QgZGVwZW5kZW50IHRhc2tzLmApXG5cbiAgbGV0IGVucnR5cG9pbnRLZXkgPSAnY2xpJ1xuICBpZiAoIXRhcmdldFByb2plY3RDb25maWc/LmVudHJ5cG9pbnQgfHwgIXRhcmdldFByb2plY3RDb25maWc/LmVudHJ5cG9pbnRbZW5ydHlwb2ludEtleV0pIHJldHVyblxuXG4gIGxldCBzY3JpcHRUYXJnZXRGaWxlID0gcGF0aC5qb2luKHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LnNvdXJjZSwgdGFyZ2V0UHJvamVjdENvbmZpZy5lbnRyeXBvaW50W2VucnR5cG9pbnRLZXldKVxuICBsZXQgZW50cnlwb2ludEZvbGRlciA9IHBhdGguam9pbih0YXJnZXRQcm9qZWN0Q29uZmlnLmRpcmVjdG9yeS5yb290LCBgLi9lbnRyeXBvaW50LyR7ZW5ydHlwb2ludEtleX1gKVxuXG4gIC8vIHBhdGggdG8gdGhlIHRhcmdldCBzY3JpcHQgZmlsZSBmcm9tIHRoZSBlbnRyeXBvaW50IGZpbGUuXG4gIGxldCByZWxhdGl2ZVRhcmdldEZpbGUgPSBwYXRoLnJlbGF0aXZlKGVudHJ5cG9pbnRGb2xkZXIsIHNjcmlwdFRhcmdldEZpbGUpXG5cbiAgbGV0IGRlc3RpbmF0aW9uRm9sZGVyID0gcGF0aC5qb2luKHRhcmdldFByb2plY3RDb25maWcuZGlyZWN0b3J5LmRpc3RyaWJ1dGlvbiwgcGF0aC5yZWxhdGl2ZSh0YXJnZXRQcm9qZWN0Q29uZmlnLmRpcmVjdG9yeS5yb290LCBlbnRyeXBvaW50Rm9sZGVyKSlcbiAgYXdhaXQgZmlsZXN5c3RlbS5ta2RpcihkZXN0aW5hdGlvbkZvbGRlciwgeyByZWN1cnNpdmU6IHRydWUgfSkgLy8gY3JlYXRlIGZvbGRlciByZWN1cnNpdmVseVxuXG4gIC8vIGNyZWF0ZSBlbnRyeXBvaW50XG4gIGxldCBmaWxlUGF0aCA9IHBhdGguam9pbihkZXN0aW5hdGlvbkZvbGRlciwgJ2luZGV4LmpzJylcbiAgbGV0IGNvbnRlbnQgPSBgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcke3JlbGF0aXZlVGFyZ2V0RmlsZX0nKWBcbiAgY29udGVudCA9IGAjXFwhL3Vzci9iaW4vZW52IG5vZGVcXG5gICsgY29udGVudFxuICBhd2FpdCBmaWxlc3lzdGVtLmFwcGVuZEZpbGUoZmlsZVBhdGgsIGNvbnRlbnQsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KVxufVxuIl19