"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.shouldTranspile = void 0;var _assert = _interopRequireDefault(require("assert"));
var _path = _interopRequireDefault(require("path"));
const normalizeArray = array => array.map(p => _path.default.normalize(p));








const shouldTranspile = ({ node, context, traverseCallContext }) => {var _targetNode$propertie, _ref, _ref2, _targetProjectConfig$;
  let targetNode = traverseCallContext.targetNode ? traverseCallContext.targetNode : node;

  let argumentObject = context === null || context === void 0 ? void 0 : context.argumentObject;
  let targetProjectConfig = context === null || context === void 0 ? void 0 : context.targetProjectConfig;
  (0, _assert.default)(targetProjectConfig, `• Context "targetProjectConfig" variable is required to run project dependent conditions.`);
  let currentNodeDirectory = ((_targetNode$propertie = targetNode.properties) === null || _targetNode$propertie === void 0 ? void 0 : _targetNode$propertie.relativePath) && _path.default.normalize(targetNode.properties.relativePath);
  (0, _assert.default)(currentNodeDirectory, `• relativePath must exist on stage targetNode that uses this condition for evaluation.`);
  let parameterCompileArray = (_ref = (argumentObject === null || argumentObject === void 0 ? void 0 : argumentObject.compile) || [], normalizeArray(_ref));
  let configCompileArray = (_ref2 = ((_targetProjectConfig$ = targetProjectConfig.build) === null || _targetProjectConfig$ === void 0 ? void 0 : _targetProjectConfig$.compile) || [], normalizeArray(_ref2));

  return [...parameterCompileArray, ...configCompileArray].includes(currentNodeDirectory);
};exports.shouldTranspile = shouldTranspile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NvdXJjZS9mdW5jdGlvbi9jb25kaXRpb24uanMiXSwibmFtZXMiOlsibm9ybWFsaXplQXJyYXkiLCJhcnJheSIsIm1hcCIsInAiLCJwYXRoIiwibm9ybWFsaXplIiwic2hvdWxkVHJhbnNwaWxlIiwibm9kZSIsImNvbnRleHQiLCJ0cmF2ZXJzZUNhbGxDb250ZXh0IiwidGFyZ2V0Tm9kZSIsImFyZ3VtZW50T2JqZWN0IiwidGFyZ2V0UHJvamVjdENvbmZpZyIsImN1cnJlbnROb2RlRGlyZWN0b3J5IiwicHJvcGVydGllcyIsInJlbGF0aXZlUGF0aCIsInBhcmFtZXRlckNvbXBpbGVBcnJheSIsImNvbXBpbGUiLCJjb25maWdDb21waWxlQXJyYXkiLCJidWlsZCIsImluY2x1ZGVzIl0sIm1hcHBpbmdzIjoiaU1BQUE7QUFDQTtBQUNBLE1BQU1BLGNBQWMsR0FBR0MsS0FBSyxJQUFJQSxLQUFLLENBQUNDLEdBQU4sQ0FBVUMsQ0FBQyxJQUFJQyxjQUFLQyxTQUFMLENBQWVGLENBQWYsQ0FBZixDQUFoQzs7Ozs7Ozs7O0FBU08sTUFBTUcsZUFBZSxHQUFHLENBQUMsRUFBRUMsSUFBRixFQUFRQyxPQUFSLEVBQWlCQyxtQkFBakIsRUFBRCxLQUE0QztBQUN6RSxNQUFJQyxVQUFVLEdBQUdELG1CQUFtQixDQUFDQyxVQUFwQixHQUFpQ0QsbUJBQW1CLENBQUNDLFVBQXJELEdBQWtFSCxJQUFuRjs7QUFFQSxNQUFJSSxjQUFjLEdBQUdILE9BQUgsYUFBR0EsT0FBSCx1QkFBR0EsT0FBTyxDQUFFRyxjQUE5QjtBQUNBLE1BQUlDLG1CQUFtQixHQUFHSixPQUFILGFBQUdBLE9BQUgsdUJBQUdBLE9BQU8sQ0FBRUksbUJBQW5DO0FBQ0EsdUJBQU9BLG1CQUFQLEVBQTZCLDJGQUE3QjtBQUNBLE1BQUlDLG9CQUFvQixHQUFHLDBCQUFBSCxVQUFVLENBQUNJLFVBQVgsZ0ZBQXVCQyxZQUF2QixLQUF1Q1gsY0FBS0MsU0FBTCxDQUFlSyxVQUFVLENBQUNJLFVBQVgsQ0FBc0JDLFlBQXJDLENBQWxFO0FBQ0EsdUJBQU9GLG9CQUFQLEVBQThCLHdGQUE5QjtBQUNBLE1BQUlHLHFCQUFxQixXQUFHLENBQUFMLGNBQWMsU0FBZCxJQUFBQSxjQUFjLFdBQWQsWUFBQUEsY0FBYyxDQUFFTSxPQUFoQixLQUEyQixFQUE5QixFQUFvQ2pCLGNBQXBDLE9BQXpCO0FBQ0EsTUFBSWtCLGtCQUFrQixZQUFHLDBCQUFBTixtQkFBbUIsQ0FBQ08sS0FBcEIsZ0ZBQTJCRixPQUEzQixLQUFzQyxFQUF6QyxFQUErQ2pCLGNBQS9DLFFBQXRCOztBQUVBLFNBQU8sQ0FBQyxHQUFHZ0IscUJBQUosRUFBMkIsR0FBR0Usa0JBQTlCLEVBQWtERSxRQUFsRCxDQUEyRFAsb0JBQTNELENBQVA7QUFDRCxDQVpNLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCdcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5jb25zdCBub3JtYWxpemVBcnJheSA9IGFycmF5ID0+IGFycmF5Lm1hcChwID0+IHBhdGgubm9ybWFsaXplKHApKVxuXG4vKiogQ29uZGl0aW9uIHBhcmFtZXRlciBoaWVyYXJjaHkgZm9yIGV2YWx1YXRpbmcgYSBub2RlIGFuZCBkZWNpZGluZyB3aGljaCBldmFsdWF0aW9uIGNvbmZpZ3VyYXRpb24gdG8gdXNlOlxuICogMS4gaW1tZWRpYXRlIHZhbHVlIGBzd2l0Y2hWYWx1ZWAgcHJvcGVydHkgb2YgdGhlIGV2YWx1YXRpb24gbm9kZSAodGhpcyBpcyBhbiBpbnRlcm5hbCBpbXBsZW1lbnRhdGlvbikuXG4gKiAyLiBEaXJlY3RseSBwYXNzZWQgcGFyYW1ldGVycyB0aGF0IHdvdWxkIGVuZCB1cCBpbiB0aGUgYGdyYXBoSW5zdGFuY2UuY29udGV4dGBcbiAqICAgIGUuZy4gYHlhcm4gcnVuIHNjcmlwdE1hbmFnZXIgc2hvdWxkQ29tcGlsZVNjcmlwdD10cnVlIEpTUHJvamVjdC9idWlsZFNvdXJjZUNvZGUgXCIubW9kdWxlUHJvamVjdCh7fSwge2NvbXBpbGU6IFsnLi90ZXN0J119KVwiYFxuICogMy4gUHJvamVjdCBjb25maWd1cmF0aW9uIHZhbHVlcyB0aGF0IHdvdWxkIGJlIGNoZWNrZWRcbiAqICAgIGUuZy4gYHByb2plY3QuY29uZmlndXJhdGlvbi5idWlsZC5jb21waWxlID0gWycuL3NvdXJjZScsICcuL3NjcmlwdCcgXWBcbiAqL1xuZXhwb3J0IGNvbnN0IHNob3VsZFRyYW5zcGlsZSA9ICh7IG5vZGUsIGNvbnRleHQsIHRyYXZlcnNlQ2FsbENvbnRleHQgfSkgPT4ge1xuICBsZXQgdGFyZ2V0Tm9kZSA9IHRyYXZlcnNlQ2FsbENvbnRleHQudGFyZ2V0Tm9kZSA/IHRyYXZlcnNlQ2FsbENvbnRleHQudGFyZ2V0Tm9kZSA6IG5vZGUgLy8gb2JqZWN0IHRvIGNoZWNrIHRoZSBjb25kaXRpb24gb24uXG4gIC8vIFJlcXVpcmVzIGBjb250ZXh0LnRhcmdldFByb2plY3RDb25maWdgIHByb3BlcnR5IHRvIGJlIHByb3ZpZGVkLlxuICBsZXQgYXJndW1lbnRPYmplY3QgPSBjb250ZXh0Py5hcmd1bWVudE9iamVjdCAvLyBkaXJlY3RseSBwYXNzZWQgcGFyYW1ldGVycyB0byB0aGUgQ29udGV4dCBpbnN0YW5jZSBvZiB0aGUgY29uZmlndXJlZCBncmFwaC5cbiAgbGV0IHRhcmdldFByb2plY3RDb25maWcgPSBjb250ZXh0Py50YXJnZXRQcm9qZWN0Q29uZmlnIC8vIHBhcmFtZXRlcnMgaW4gdGhlIGNvbmZpZ3VyYXRpb24gZmlsZS5cbiAgYXNzZXJ0KHRhcmdldFByb2plY3RDb25maWcsIGDigKIgQ29udGV4dCBcInRhcmdldFByb2plY3RDb25maWdcIiB2YXJpYWJsZSBpcyByZXF1aXJlZCB0byBydW4gcHJvamVjdCBkZXBlbmRlbnQgY29uZGl0aW9ucy5gKVxuICBsZXQgY3VycmVudE5vZGVEaXJlY3RvcnkgPSB0YXJnZXROb2RlLnByb3BlcnRpZXM/LnJlbGF0aXZlUGF0aCAmJiBwYXRoLm5vcm1hbGl6ZSh0YXJnZXROb2RlLnByb3BlcnRpZXMucmVsYXRpdmVQYXRoKVxuICBhc3NlcnQoY3VycmVudE5vZGVEaXJlY3RvcnksIGDigKIgcmVsYXRpdmVQYXRoIG11c3QgZXhpc3Qgb24gc3RhZ2UgdGFyZ2V0Tm9kZSB0aGF0IHVzZXMgdGhpcyBjb25kaXRpb24gZm9yIGV2YWx1YXRpb24uYClcbiAgbGV0IHBhcmFtZXRlckNvbXBpbGVBcnJheSA9IGFyZ3VtZW50T2JqZWN0Py5jb21waWxlIHx8IFtdIHw+IG5vcm1hbGl6ZUFycmF5XG4gIGxldCBjb25maWdDb21waWxlQXJyYXkgPSB0YXJnZXRQcm9qZWN0Q29uZmlnLmJ1aWxkPy5jb21waWxlIHx8IFtdIHw+IG5vcm1hbGl6ZUFycmF5XG5cbiAgcmV0dXJuIFsuLi5wYXJhbWV0ZXJDb21waWxlQXJyYXksIC4uLmNvbmZpZ0NvbXBpbGVBcnJheV0uaW5jbHVkZXMoY3VycmVudE5vZGVEaXJlY3RvcnkpXG59XG4iXX0=